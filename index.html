<script>
  // UUID constants for FTMS and Cycling Power Service (CPS)
  const FTMS_SERVICE = "00001826-0000-1000-8000-00805f9b34fb";
  const FTMS_INDOOR_BIKE_DATA = "00002ad2-0000-1000-8000-00805f9b34fb";

  const CPS_SERVICE = "00001818-0000-1000-8000-00805f9b34fb";
  const CPS_MEAS = "00002a63-0000-1000-8000-00805f9b34fb";

  let timerInterval = null;
  let elapsedSeconds = 0;

  function formatTime(s) {
    const h = String(Math.floor(s / 3600)).padStart(2, "0");
    const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
    const sec = String(s % 60).padStart(2, "0");
    return `${h}:${m}:${sec}`;
  }
  function startTimer() {
    if (!timerInterval) {
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        document.getElementById("timer").innerText = formatTime(elapsedSeconds);
      }, 1000);
    }
  }
  function stopTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
  }
  function resetTimer() {
    stopTimer();
    elapsedSeconds = 0;
    document.getElementById("timer").innerText = "00:00:00";
  }
  function updateDisplay(watts, cadence, totalJoules) {
    document.getElementById("power").innerText = `Power: ${watts} W`;
    document.getElementById("cadence").innerText = `Cadence: ${Math.round(cadence)} RPM`;
    document.getElementById("work").innerText = `Work: ${totalJoules} J`;
  }

  // Little endian helpers
  const u8 = (dv, o) => dv.getUint8(o);
  const u16 = (dv, o) => dv.getUint16(o, true);
  const s16 = (dv, o) => dv.getInt16(o, true);

  async function connectToDevice() {
    try {
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ services: [FTMS_SERVICE] }, { services: [CPS_SERVICE] }],
        optionalServices: [FTMS_SERVICE, CPS_SERVICE]
      });

      const server = await device.gatt.connect();

      // Try FTMS first, then fall back to CPS
      let service = null, characteristic = null, mode = null;
      try {
        service = await server.getPrimaryService(FTMS_SERVICE);
        characteristic = await service.getCharacteristic(FTMS_INDOOR_BIKE_DATA);
        mode = "FTMS";
      } catch {
        service = await server.getPrimaryService(CPS_SERVICE);
        characteristic = await service.getCharacteristic(CPS_MEAS);
        mode = "CPS";
      }

      await characteristic.startNotifications();
      characteristic.addEventListener("characteristicvaluechanged", evt => {
        const dv = evt.target.value;
        if (mode === "FTMS") {
          handleFtms(dv);
        } else {
          handleCps(dv);
        }
      });

      alert(`Connected, mode: ${mode}`);
      startTimer();
    } catch (e) {
      console.error(e);
      alert("Connection failed: " + e.message);
    }
  }

  // FTMS Indoor Bike Data (0x2AD2)
  let ftmsEnergyJ = 0;
  function handleFtms(dv) {
    let offset = 0;
    const flags = u16(dv, offset);
    offset += 2;

    // Skip fields based on flags
    if (flags & 0x0001) { offset += 2; } // More Data
    if (flags & 0x0002) { offset += 2; } // Avg Speed
    let cadence = null;
    if (flags & 0x0004) { cadence = u16(dv, offset) / 2; offset += 2; } // Cadence (0.5 RPM units)
    if (flags & 0x0008) { offset += 2; } // Avg Cadence
    if (flags & 0x0010) { offset += 3; } // Total Distance (m, 24 bit)
    if (flags & 0x0020) { offset += 2; } // Resistance Level
    let watts = null;
    if (flags & 0x0040) { watts = s16(dv, offset); offset += 2; } // Instant Power (W)
    if (flags & 0x0080) { offset += 2; } // Avg Power

    // Energy fields per spec
    let totalEnergyKJ = null;
    if (flags & 0x0100) { totalEnergyKJ = u16(dv, offset); offset += 2; } // Total Energy (kJ)
    if (flags & 0x0200) { offset += 2; } // Energy Per Hour
    if (flags & 0x0400) { offset += 1; } // Energy Per Minute

    // Compute work in Joules
    if (totalEnergyKJ != null) ftmsEnergyJ = totalEnergyKJ * 1000;

    if (watts == null && cadence == null) return;
    updateDisplay(watts ?? 0, cadence ?? 0, ftmsEnergyJ || 0);
  }

  // Cycling Power Measurement (0x2A63)
  let cpsEnergyJ = 0;
  let lastCrank = null;
  function handleCps(dv) {
    let offset = 0;
    const flags = u16(dv, offset);
    offset += 2;

    const watts = s16(dv, offset);
    offset += 2;

    // Pedal balance present (bit0)
    if (flags & 0x0001) offset += 1;
    // Accumulated Torque present (bit2)
    if (flags & 0x0004) offset += 2;
    // Wheel Revolution Data present (bit4)
    if (flags & 0x0010) {
      offset += 6;
    }
    // Crank Revolution Data present (bit5)
    let cadence = null;
    if (flags & 0x0020) {
      const revs = u16(dv, offset);
      offset += 2;
      const lastEvent = u16(dv, offset);
      offset += 2; // time in 1/1024 s
      if (lastCrank) {
        const dRevs = (revs - lastCrank.revs + 65536) % 65536;
        const dTime = ((lastEvent - lastCrank.time + 65536) % 65536) / 1024;
        if (dTime > 0) cadence = (dRevs / dTime) * 60;
      }
      lastCrank = { revs, time: lastEvent };
    }
    // Extreme Angles present (bit6)
    if (flags & 0x0040) offset += 3;
    // Top and Bottom Dead Spot Angles present (bit7)
    if (flags & 0x0080) offset += 4;
    // Accumulated Energy present (bit11)
    if (flags & 0x0800) {
      const kJ = u16(dv, offset);
      offset += 2;
      cpsEnergyJ = kJ * 1000;
    }

    updateDisplay(watts, cadence ?? 0, cpsEnergyJ || 0);
  }

  // Wire up your buttons
  window.connectToDevice = connectToDevice;
  window.startTimer = startTimer;
  window.stopTimer = stopTimer;
  window.resetTimer = resetTimer;
</script>

